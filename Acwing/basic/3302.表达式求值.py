'''其实总体思路是中缀表达式先转成后缀表达式再求值的过程,y总的代码是把这两步一起做的。
/*
* y总的视频后,我对y总做法的浅薄理解:
*
* “假设”我们有一颗二叉树，它的叶子结点是数，其它结点是运算符。
* 这颗二叉树自根节点至叶子结点运算符的优先级逐级递增，也即根节点的优先级最低。
* 所以我们只需要将左右子树结果计算出来后，再根据根节点计算最终结点即可。
*
* 人为去建立一颗这样的树很麻烦，我们可以用栈模拟这样的一个过程。
* 我们发现，想要计算某个结点的运算符，必要条件是左右子树都已经计算完。
* 比如：(1+1)(2+2),显然由于括号的存在，此处‘’的优先级要低于此处的‘+’，我们要计算‘’需要先计算两边的‘+’。
*
* 那么就有一个问题：如何判断一个结点的左右子树已经遍历完？
* 很显然，当我们向上走（换句话说就是当前运算符的优先级低于上一个运算符，因为我们假设存在的这棵树根节点的运算符优先级最低）时
* 该结点的左右子树已经计算完。也就是这句话:while(!op.empty()&&prority[x]<=prority[op.top()])eval();
* 在入栈前将栈内优先级更高的运算符计算完再入栈。
*
* 另外因为括号无视优先级，需要优先计算括号内的数，那么我们在遇到‘)’时可以直接将栈内的数从后向前计算出来
* (在入栈时已经保证了优先级自后向前升高)，直到遇到‘(’停止。
*
* 这样，这棵树就完美的用栈模拟出来了。个人浅薄理解，不准确的地方欢迎指正。
*
**/

链接:https://www.acwing.com/video/2616/
'''

# 两个栈，一个数栈，一个运算符栈
nums, ops = [], []
prority = {'-': 0, '+': 0, '*': 1, '/': 1}

char = input()
n = len(char)

def eval():
    op = ops.pop()
    b = nums.pop()
    a = nums.pop()
    if op == "+": a += b
    elif op == "-": a -= b
    elif op == "*": a *= b
    else: a = int(a / b)
    nums.append(a)

i = 0
while i < n:
    if char[i].isdigit():
        num = 0
        # 让完整的一个数输入
        while i < n and char[i].isdigit():
            num = num * 10 + int(char[i])
            i += 1
        nums.append(num)
        continue
    elif char[i] == ')':
        # 因为是用list代替栈，所以ops[-1]是指ops栈的栈顶
        # 如果栈顶是(,意味着当前遇到的计算是(num)，这个就不用算了，直接让(出栈就行了
        while ops[-1] != '(': eval()
        ops.pop()
    elif char[i] == '(': ops.append('(')
    else:
        # 如果在括号内的第一个运算符，则不计算，因为第二个数还没进来。如果是第二个运算符，就计算前一个（优先级允许时）然后再入栈当前这一个
        while ops and ops[-1] != '(' and prority[ops[-1]] >= prority[char[i]]: eval()
        # 注意这个入栈操作不是在while里面
        ops.append(char[i])
    i += 1
while ops: eval()
print(nums[-1])

