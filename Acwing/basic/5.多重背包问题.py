'''和多重背包I一样

考察的是二进制优化

上道题的复杂度是三个循环NxVx总s  n^3,但是这题数据范围超过太多了肯定TLE

二进制优化:
    把所有物品拆开, 每个物品拆开, s个就拆成s种物品, 转换成了01背包问题.
    但是直接这么拆复杂度还是不变的.

    因此要二进制拆.
    直接拆, 某个物品有7个, 拆成7种物品,每个1 1 1 1 1 1 1种.
    这样直接拆种类太多,有没有什么方法用更少的种类表达所有的组合呢?

    想到2进制. 1, 2, 4

    一般情况,s拆成01背包:
        当是2的幂时, 可以拆成拆成[log2(s)上取整]种.
        当不是时, 比如10,拆成1, 2, 4 和一个额外的3即可.

    此时每个物品我们只分成了log2(s)份, 也就是N x V x log(s)的复杂度.


    数据范围

    0<N≤1000
    0<V≤2000
    0<vi,wi,si≤2000
'''

if __name__ == "__main__":
    N, V = map(int, input().split())

    v, w = [0] * 2000 * 12, [0] * 2000 * 12 # v和w需要预留有可能存下所有拆分方式,12是log(2000) 
    
    # 不需要记录每个真正的种类可以拆成多少份,只需要记录种的分类,因为当场01背包每个都是不同的种类
    # 拆分
    cnt = 1
    for _ in range(N):
        vv, ww, ss = map(int, input().split())
        # 计算log(ss)的循环, k是当前二进制拆分方案中的当前迭代应该承上的份数
        k = 1 # 每个种类至少有1,因此0不考虑
        while k <= ss:
            v[cnt] = vv * k # 当前是总的第cnt - 1个种类, 根据当前的拆分, 该种类的体积为vv * k.
            w[cnt] = ww * k
            
            ss -= k
            k *= 2 # k需要放在最后再自增
            cnt += 1
            
        if ss:
            # 说明ss不是2的整次幂, 差的那份拆分补上就行
            v[cnt] = vv * ss # 就用这个方法  错误的那个方法别用了:是111(2) = 1000(2)-1
            w[cnt] = ww * ss
            cnt += 1
    # 01背包
    f = [[0] * (V + 10) for _ in range(cnt + 10)]
    for i in range(1, cnt + 1):
        for j in range(V + 1):
            f[i][j] = f[i - 1][j]
            if j >= v[i]:
                # try:
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i])
                # except IndexError:
                #     print("#")
                #     print(i,j)
                #     print(cnt,V)
                #     print(v[i])
                #     print(v[:1000])
    print(f[cnt -1][V])