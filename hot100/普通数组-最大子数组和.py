'''中等

思考:
前缀和?
    先找到前缀和最大的, 然后再找前缀和最小的(且为负数)  错了!

是动态规划
    重点是理解连续
    这里要明确 dp[i] 存储的不是从 0 到 i 这个范围内所得到的最大的连续子数组的和，而是以 nums[i] 为结尾的子数组所能达到的最大的和。
'''

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        
        for i in range(1, len(nums)):
            # 如果一项导致整个连续子数组为负了, 那么就没有必要选了, 就选0, 相当于不连续了重新开始找子序列.
            # 然后最后遍历整个数组的最大值.  如果全是负数, 因为是求和, 负数越加越小, 正数越加越大, 所以找到的一定是连续数组
            nums[i] = nums[i] + max(nums[i - 1],0)
        # dp: 

        
